import json
from pathlib import Path

# Load schema.json
schema_path = Path("tiptap_schema_extractor/editor_schema.json")
schema = json.loads(schema_path.read_text())


# Helper to convert ProseMirror content expressions to Python type hints
def parse_content_expr(expr: str | None) -> str:
    if not expr:
        return None

    parts = expr.split()
    types = []

    for part in parts:
        if part.endswith("+"):
            base = part[:-1]
            types.append(f"List['{base.title()}Node']")
        elif part.endswith("*"):
            base = part[:-1]
            types.append(f"Optional[List['{base.title()}Node']]")
        else:
            types.append(f"'{part.title()}Node'")

    return f"Union[{', '.join(types)}]" if len(types) > 1 else types[0]


# Collect nodes by group for union types
group_map = {"inline": [], "block": [], "list": []}

for name, spec in schema.get("nodes", {}).items():
    groups = spec.get("group", "")
    if groups:
        for g in groups.split():
            if g in group_map:
                node_name = name.title() + "Node"
                group_map[g].append(f"'{node_name}'")


# Helper to generate union type declarations
def gen_union_type(name: str, types: list[str]) -> str:
    if not types:
        return f"{name} = None"
    return f"{name} = Union[{', '.join(types)}]"


# Generate Pydantic class for a node or mark
def gen_node_class(name: str, node_spec: dict, kind: str = "Node") -> str:
    class_name = name.title().replace("_", "") + kind
    type_field = f'type: Literal["{name}"] = "{name}"'
    attrs = node_spec.get("attrs", {})

    if name == "text":
        # special case for text node: has required 'text' field, no attrs, no content
        return """
class TextNode(TiptapNode):
    type: Literal["text"] = "text"
    text: str
    """

    if attrs:
        attr_fields = []
        for attr_name, attr_spec in attrs.items():
            default = attr_spec.get("default", None)
            py_type = type(default).__name__ if default is not None else "Any"
            # Optional if default is None
            if default is None:
                attr_fields.append(f"    {attr_name}: Optional[{py_type}] = None")
            else:
                attr_fields.append(f"    {attr_name}: {py_type} = {repr(default)}")

        attrs_model = f"\nclass {class_name}Attrs(BaseModel):\n" + (
            "\n".join(attr_fields) if attr_fields else "    pass"
        )
        attrs_field = f"attrs: {class_name}Attrs = {class_name}Attrs()"
    else:
        attrs_model = ""
        attrs_field = None

    content_type = parse_content_expr(node_spec.get("content"))
    content_field = f"content: {content_type}" if content_type else None

    class_content = "\n".join(
        [f"    {line}" for line in [type_field, attrs_field, content_field] if line]
    )

    return f"""{attrs_model}

    
class {class_name}(TiptapNode):
{class_content}
"""


# Generate output Python code
output = [
    "# DO NOT EDIT. This file was automatically generated by generate_prose_mirror_classes.py.",
    "from pydantic import BaseModel\nfrom typing import List, Optional, Union, Literal, Any\n",
]

output.append("""
# Common parent class for all Tiptap nodes
class TiptapNode(BaseModel):
    # Base class for all Tiptap/ProseMirror nodes
    pass
""")

# Generate group unions
output.append("# Node group unions for convenience\n")
output.append(gen_union_type("InlineNode", group_map["inline"]))
output.append(gen_union_type("BlockNode", group_map["block"]))
output.append(gen_union_type("ListNode", group_map["list"]))
output.append("")

for name, spec in schema.get("nodes", {}).items():
    output.append(gen_node_class(name, spec, kind="Node"))

# Write to file
output_path = Path("tiptap_models.py")
output_path.write_text("\n".join(output))

print("âœ… Generated tiptap_models.py with group unions and conditional attrs classes.")
